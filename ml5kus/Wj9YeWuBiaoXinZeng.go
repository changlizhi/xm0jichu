package ml5kus

//当一个业务数据需要新增时需要先知道自己到底有哪些字段是可以新增的，每个字段受限情况如何，比如新增一个用户，用户的字段那么多肯定不会一次性就添加好也不会一次性查那么多，我现在设计这个系统最大的问题是每个业务的数据字段整体上来说增加了两倍，但是从拆解上来说完全是一种很优秀的设计，因为避免了结构性数据在数据表中过于牵连的问题，这是把数据字段全都设计在一个表中的问题所在，实际上没人关心你的数据库怎么设计的，只要能完成业务就行了。
//现在是基础查询的阶段，外部调用时把所有需要查看的字段组装好，可以提供一个查询所有字段的函数
//在这里就全都进行左外关联
//然后条件就是字段名和值的关系，因为字段名肯定是编码，此时字段名对应着字段值表名，所以可以通过字段名拿到需要组装的值表名进行条件拼装
//其实这里就是分析增删改查之间的共性提炼函数，然后也要分析差别做不同的返回
//正常使用时数据结构应该保持在缓存里，直接从缓存拿是最好的，注意缓存更新机制即可，系统重启时，数据新增或删除时，整体定时任务以防万一

func YeWuBiaoXinZeng(canShu map[string]interface{}) map[string]interface{}{
  //首先新增一个主键表的值，然后拿着这个主键表的主键
  //然后查出这个表拥有多少字段，根据字段的正则校验数据是否符合数据库需要，
  //把值和第一步拿到的主键存入各自的字段值表
  //按照一般的数据库入表设计 INSERT INTO CaoZuoKu.CaoZuoBiao(ZiDuans) values(Zhis)
  //拆分出来就是一个for循环下所有字段的入库，这里要做一个事务保证每个表插入的数据没问题，
  //从数据入库的情况来看，所有的字段都在缓存拿到，但实际上只会插入其中几个字段值，所以缓存设计时要注意把表中的字段用map限制起来，以字段名为键整个字段说明为值
  //由于字段是全局的不允许有重复，所以字段即使只做一个大map也是没问题的，当然最外层还是用表作为map的值更好，因为操作的表和字段都是需要传到数据库的。
  //更好的做法还是每个系统都提供一个各自的数据库map下面有多个表的map，再下面有字段的map，这样就能更方便的拼装sql了。
  //也可以做成懒加载的方式，因为只有增删改查的时候会获取这个数据，这时候再去拿缓存也是合适的
  //只去拿数据库进行缓存，不再在文件内存中拿常量，因为这不稳定，增加字段时需要重启就很不好。
  HuanCunSuoYouJieGou()
  caoZuoKu 
  caoZuoBiao 
  ziDuanHeZhis 
  ziDuanBiaos
  tiaoJians
}
func YeWuBiaoShanChu(canShu map[string]interface{}) map[string]interface{}{
  //根据传入的字段和条件查到在哪个表，
  //进入那个表把数据查出来，可能有多条时就要看其他字段的限制比如用户，此时要用左外关联的方式
  //拿到一条或多条，把这个表所有的字段值表这个主键下的数据都删了
  
}

func YeWuBiaoXiuGai(canShu map[string]interface{}) map[string]interface{}{
  //根据传入的字段和条件查到在哪个表，
  //进入那个表把数据查出来，可能有多条时就要看其他字段的限制比如用户，此时要用左外关联的方式
  //拿到一条或多条，把这个表所有的字段值表这个主键下的数据都修改了
  
}

func YeWuBiaoChaXun(canShu map[string]interface{}) map[string]interface{}{
  //根据传入的字段和条件查到在哪个表，
  //进入那个表把数据查出来，可能有多条时就要看其他字段的限制比如用户，此时要用左外关联的方式
  //拿到一条或多条，把这个表所有的字段值表这个主键下的数据都修改了
  
}

